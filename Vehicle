#Generating Vehicles
class Vehicle:
    def __init__(self, index, dispatchings, initial_location, curr_location, capacity):
      self.index = index
      self.dispatchings = dispatchings
      self.initial_location = initial_location
      self.curr_location = curr_location
      self.capacity = capacity

def overlaps_vehicle(new_Reservation, Vehicle):
  #print(len(Vehicle.dispatchings))
  vehicle_dispatchings = Vehicle.dispatchings
  if len(vehicle_dispatchings) == 0:
    return (False, 0)

  #만약 새로운 예약이 vehicle 예약 리스트에 가장 첫번째에 위치할 경우
  if new_Reservation.start_time < vehicle_dispatchings[0].start_time:
    if new_Reservation.end_time <= vehicle_dispatchings[0].start_time:  #travel time이 0인 경우도 있으니까 등호도 포함?
      if travel_time_list[new_Reservation.end_location[1]][vehicle_dispatchings[0].start_location[1]] <= (vehicle_dispatchings[0].start_time - new_Reservation.end_time): #등호 포함 추가
        return (False,0)
      else: return (True, 100000)
    else: return (True, 100000)


  #만약 새로운 예약이 vehicle 예약 리스트에 가장 마지막에 위치할 경우
  elif new_Reservation.start_time >= vehicle_dispatchings[-1].end_time:  #travel time이 0인 경우도 있으니까 등호도 포함?
    if travel_time_list[vehicle_dispatchings[-1].end_location[1]][new_Reservation.start_location[1]] <= (new_Reservation.start_time - vehicle_dispatchings[-1].end_time):
      return (False,-1)
    else: return (True, 100000)


  #만약 새로운 예약이 vehicle 예약 리스트에서 예약들 사이에 위치할 경우
  else:
    for i in range(len(vehicle_dispatchings)-1):
      if vehicle_dispatchings[i].end_time <= new_Reservation.start_time:  #새로운 예약의 시작 시간이 비교 예약의 종료 시간 이후인 경우
        if travel_time_list[vehicle_dispatchings[i].end_location[1]][new_Reservation.start_location[1]] <= (new_Reservation.start_time - vehicle_dispatchings[i].end_time): #이전 예약과의 거리 조건
          if new_Reservation.end_time <= vehicle_dispatchings[i+1].start_time:  #새로운 예약의 종료 시간이 다음 예약의 시작 시간보다 앞선 경우
            if travel_time_list[new_Reservation.end_location[1]][vehicle_dispatchings[i+1].start_location[1]] <= (vehicle_dispatchings[i+1].start_time - new_Reservation.end_time): #다음 예약과의 거리 조건
              return (False, i+1)
            else: return (True, 100000)
          elif vehicle_dispatchings[i+1].end_time <= new_Reservation.start_time:
            continue
          else: return (True, 100000)
        else: return (True, 100000)
      else: return (True, 100000)

  return (True, 100000)
